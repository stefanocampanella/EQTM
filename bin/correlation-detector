#! /usr/bin/env python
import argparse
import logging
from concurrent.futures import ThreadPoolExecutor
from importlib import resources
from pathlib import Path
from time import perf_counter as timer

import bottleneck as bn
import numpy as np
from fastavro.schema import load_schema
from obspy import Stream
from psutil import cpu_count
from scipy.signal import find_peaks
from tqdm import tqdm

try:
    import cupy
except ImportError:
    cupy = None

import correlation_detector as cd

parser = argparse.ArgumentParser(prog="correlation-detector")
parser.add_argument("data", help="Continuous data path", type=Path)
parser.add_argument("travel_times", help="Path to travel times directory", type=Path)
parser.add_argument("templates", help="Path to templates directory", type=Path)
parser.add_argument("output", help="Output file path")
parser.add_argument("--max_channels", help="Maximum number of channels used for computing cross-correlation", type=int,
                    default=15)
parser.add_argument("--lowpass", help="Lowpass filter frequency", type=float, default=3.0)
parser.add_argument("--highpass", help="Highpass filter frequency", type=float, default=8.0)
parser.add_argument("--relative_height", help="Scale factor of mean correlation peak threshold", type=float,
                    default=6.0)
parser.add_argument("--relative_distance", help="Scale factor of mean correlation peak distance", type=float,
                    default=2.0)
parser.add_argument("--tolerance", help="Maximum lag in samples", type=int, default=6)
parser.add_argument("--buffer_size", help="Maximum lag in samples", type=int, default=4096)
parser.add_argument("--log", help="Log level", default='warning')
parser.add_argument("--threads", help="Number of threads to use", type=int, default=0)
parser.add_argument("--progress", help="Show progress bar", default=False, action='store_true')
parser.add_argument("--json", help="Save output in json lines format", default=False, action='store_true')
parser.add_argument("--stop", help="Stop if an error occurs", default=False, action='store_true')
cli_args = parser.parse_args()

logging.basicConfig(format='%(process)s-%(levelname)s-%(asctime)s: %(message)s',
                    level=getattr(logging, cli_args.log.upper()))

with resources.path('correlation_detector', 'event.avsc') as schema_path:
    schema = load_schema(schema_path)

if cli_args.json:
    from fastavro import json_writer as writer

    output = Path(cli_args.output + '.jsonl')
    mode = 'a+'
else:
    from fastavro import writer

    output = Path(cli_args.output + '.avro')
    mode = 'a+b'

if output.exists():
    logging.warning(f"{output} already exists, it will be overwritten.")
    output.unlink()

if cupy:
    # noinspection PyUnresolvedReferences
    streams = [cupy.cuda.Stream() for _ in range(cli_args.max_channels)]
else:
    streams = [None for _ in range(cli_args.max_channels)]

if __name__ == '__main__':
    tic = timer()
    data_pool = cd.read_data(cli_args.data, freqmin=cli_args.lowpass, freqmax=cli_args.highpass)
    templates = tqdm(cd.read_templates(cli_args.templates, cli_args.travel_times),
                     total=len(list(cli_args.travel_times.glob('*.ttimes'))),
                     disable=not cli_args.progress)
    events_buffer = []
    max_workers = cli_args.threads if cli_args.threads > 0 else max(cpu_count(logical=False), cli_args.max_channels)
    with ThreadPoolExecutor(max_workers=max_workers) as pool:
        for index, template, ttimes in templates:
            try:
                data, template, ttimes = cd.match_traces(data_pool, template, ttimes, cli_args.max_channels)
                correlations = Stream(traces=pool.map(cd.correlate_trace, data, template, ttimes.values(), streams))
                if correlations:
                    mean_correlation = bn.nanmean([trace.data for trace in correlations], axis=0)
                    dmad = bn.nanmean(np.abs(mean_correlation - bn.nanmedian(mean_correlation)))
                    height = cli_args.relative_height * dmad
                    distance = max(trace.stats.npts for trace in template)
                    peaks, properties = find_peaks(mean_correlation, height=height, distance=distance)
                    detections = cd.process_detections(zip(peaks, properties['peak_heights']), correlations, data,
                                                       template, ttimes, pool, tolerance=cli_args.tolerance)
                    stds = {trace_id: std
                            for trace_id, std in pool.map(lambda trace: (trace.id, bn.nanstd(np.abs(trace.data))),
                                                          correlations)}
                    for detection in detections:
                        detection.update({'template': index, 'dmad': dmad})
                        for channel in detection['channels']:
                            channel['std'] = stds[channel['id']]
                        events_buffer.append(detection)
            except BaseException as error:
                if cli_args.stop:
                    raise error
                else:
                    logging.error(f"{error} occurred while processing template {index}")
            finally:
                if len(events_buffer) > cli_args.buffer_size:
                    with open(output, mode) as file:
                        logging.info(f"Flushing {len(events_buffer)} events to {file.name}")
                        writer(file, schema, events_buffer)
                    events_buffer.clear()
    if events_buffer:
        with open(output, mode) as file:
            logging.info(f"Writing remaining {len(events_buffer)} events to {file.name}")
            writer(file, schema, events_buffer)
    toc = timer()
    logging.info(f"Elapsed time: {toc - tic:.2f} seconds.")
