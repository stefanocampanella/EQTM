#! /usr/bin/env python
import argparse
import logging
from pathlib import Path
from random import shuffle
from time import perf_counter as timer

from tqdm import tqdm

parser = argparse.ArgumentParser(prog=Path(__file__).name)
parser.add_argument("input", help="Path to travel times directory", type=Path)
parser.add_argument("output", help="Output path", type=Path)
parser.add_argument("--log", help="Log level", default='info')
parser.add_argument("--progress", help="Show progress bar", default=False, action='store_true')
parser.add_argument("--stop", help="Stop if an error occurs", default=False, action='store_true')
cli_args = parser.parse_args()

logging.basicConfig(format='%(process)s-%(levelname)s-%(asctime)s: %(message)s',
                    level=getattr(logging, cli_args.log.upper()))


if __name__ == '__main__':
    logging.info(f"Running {parser.prog} with the following parameters: {vars(cli_args)}")
    tic = timer()

    if cli_args.input.exists():
        if cli_args.input.is_dir():
            logging.info(f"Reading from {cli_args.input}")
        else:
            raise FileExistsError(f"{cli_args.input} is not a directory")
    else:
        raise FileNotFoundError(f"{cli_args.input} does not exist")

    if cli_args.output.exists():
        if cli_args.output.is_file():
            raise FileExistsError(f"{cli_args.output} is a file")
    else:
        logging.info(f"{cli_args.output} does not exist, it will be created")
        cli_args.output.mkdir(parents=True)
    logging.info(f"Writing to {cli_args.output}")

    input_paths = cli_args.input.glob('*.ttimes')
    if cli_args.progress:
        input_paths = tqdm(input_paths)

    for input_path in input_paths:
        with input_path.open('r') as input:
            keys = []
            values = []
            while line := input.readline():
                key, value = line.split(' ')
                keys.append(key)
                values.append(value)
            shuffle(values)
            output_path = cli_args.output / input_path.name
            with output_path.open('w') as output:
                logging.debug(f"Writing to {output.name}")
                output.writelines(f"{key} {value}" for key, value in zip(keys, values))
    toc = timer()
    logging.info(f"Elapsed time: {toc - tic:.2f} seconds")
